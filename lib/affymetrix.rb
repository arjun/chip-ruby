# 
# Simple Parser for Affymetrix files in binary format
#
# See http://www.affymetrix.com/Auth/support/developer/fusion/file_formats.zip
# specifically chp-gtc.html and generic.html
#
# Author::    Arjun Sanyal (mailto:arjun.sanyal@childrens.harvard.edu)
# Copyright:: Children's Hospital Boston
# License:: GPLv2
#
#--
#
# Todo
# * tests
# * CNCNF and LOH

# The Command Console generic data file format is a file format developed by
# Affymetrix for storing a variety of Affymetrix data and results including
# scanner acquisition data and intensity and probe array analysis results.

require 'csv'

class CCGeneric
  attr_reader :filename
  VALUE_TYPES = [:byte, :ubyte, :short, :ushort, :int, :uint, :float, :string, :wstring]

  # Init the Command Console Generic date file (parent of all other files)
  # params:
  # - filename (string, required)
  # - maxlines (int, defaults to 100)
  # - verbosity (can be :normal, :verbose, :debug, :quiet)
  def initialize(params)
    
    @filename = params[:filename]
    @filesize = File.size(@filename)
    @maxlines = params[:maxlines]
    @verbosity = params[:verbosity] || :normal

    @file_header = {}
    @generic_data_headers = []
    @generic_data_header_parameters = []
    @data_groups = []
    @data_sets = []
    
    puts "Filename\n--------\n#{@filename}\n\n" unless @verbosity == :quiet
  end

  #--
  # methods for reading raw bytes
  #
  def read_ubyte(f)
    f.read(1).unpack('C')
  end

  def read_float(f)
    f.read(4).unpack('g')
  end

  def read_ushort(f)
    f.read(2).unpack('v')
  end

  def read_int(f)
    f.read(4).unpack('N')[0].to_i
  end
  
  def read_char(f)
    f.read(1).unpack('C')[0].to_s
  end

  def read_string(f, wide=nil)
    n = f.read(4).unpack('N')[0]
    wide ? f.read(n*2).to_s : f.read(n).unpack('a'+n.to_s).to_s
  end
  
  def read_parameter(f)
    [read_string(f, :wide), read_string(f), read_string(f, :wide)]
  end

  def read_column(f)
    [read_string(f, :wide), read_char(f), read_int(f)]
  end

  #--
  # methods for printing
  #

  def pretty_print_header(header)
    puts header, "-" * header.length unless @verbosity == :quiet
  end
  
  def pretty_print_parameters(h, header)
    return if @verbosity == :quiet or @verbosity == :normal
    pretty_print_header(header)
    h[:parameters].each do |p|
      puts "#{p[0]} = #{p[1]} (#{p[2]})"
    end
    puts "\n"
  end

  def pretty_print_columns(columns, header)
    return if @verbosity == :quiet
    pretty_print_header(header)
    columns.each do |c|
      puts "#{c[0]} (type: #{VALUE_TYPES[c[1].to_i]}, size: #{c[2]})"
    end
    puts "\n"
  end

  def pretty_print_hash(h, header)
    return if @verbosity == :quiet
    pretty_print_header(header)
    h.each_pair { |key, value| puts "#{key} = #{value}" }
    puts "\n"
  end

  #--
  # methods for reading file structure
  # 

  def read_file_header(f)
    @file_header = {  
      :magic_number => read_char(f), 
      :version_number => read_char(f),
      :n_data_groups => read_int(f),
      :pos_first_data_group => read_int(f)
    }
  end
  
  def read_generic_data_headers(f)
    h = {
      :data_type_id => read_string(f),
      :unique_file_id => read_string(f),
      :created_at => read_string(f),
      :locale => read_string(f, :wide), # not wstring in spec?
      :n_parameters => read_int(f),
      :parameters => [],
      :n_parent_file_headers => nil,
      :parent_file_headers => []
    }
    
    h[:n_parameters].to_i.times do
      h[:parameters] << read_parameter(f)
    end

    h[:n_parent_file_headers] = read_int(f)

    h[:n_parent_file_headers].times do |n|
      read_generic_data_headers(f)
    end

    @generic_data_headers << h
  end
    
  def read_header
    File.open(@filename, 'rb') do |f|
      read_file_header(f)
      pretty_print_hash(@file_header, "File Header")
      
      puts "Hint: set 'verbosity' to see all parameters and parent file headers\n\n" if @verbosity == :normal
            
      read_generic_data_headers(f)
      pretty_print_hash(@generic_data_headers[0], "Generic Data Header (w/o Parent File Headers)")
      pretty_print_parameters(@generic_data_headers[0], 'Parameters')
    end
  end
  
  def read_data_groups(pos = @file_header[:pos_first_data_group])
    File.open(@filename, 'rb') do |f|
      f.seek(pos)

      h = {
        :pos_next_data_group => read_int(f),
        :pos_first_data_set => read_int(f),
        :n_data_sets => read_int(f),
        :data_group_name => read_string(f, :wide)
      }

      if h[:pos_next_data_group] < @filesize then
        read_data_groups(h[:pos_next_data_group])
      end
      
      @data_groups << h
      
      pretty_print_hash(h, "Data Group Header (#{@data_groups.length})")
    end
  end
end

# The CHP files generated by the Genotyping Console software contain SNP
# analysis results from the Birdseed and BRLMM genotyping algorithms.
class CHP < CCGeneric
  def initialize(filename, *rest)
    super(filename, *rest)
    read_header
    read_data_groups
    read_data_sets
  end

  # this will be different for different things e.g. Genotyping Console vs. Expression Console (MAS5, etc)
  # make this data-driven

  # Genotyping Console
  def read_data_row(f)
    n = read_int(f)
    row = f.read(n+14).unpack('a'+n.to_s+'CgggC')
    call = case row[1]
            when 6 then 'AA'
            when 7 then 'BB'
            when 8 then 'AB'
            else        'No call'
           end
    return row, call
  end

  # Expression Console (MAS5)

  def read_background_zone_data_row(f)
    h = {
      :center_x => read_float(f),
      :center_y => read_float(f),
      :background => read_float(f),
      :smooth_factor => read_float(f)
    }

    pretty_print_hash(h, "read_background_zone_data_row") if @verbosity == :debug
    
    return h
  end

  def read_expression_results_row(f)
    h = {
      :probe_set_name => read_string(f, :wide),
      :detection => read_ubyte(f),
      :detection_p_value  => read_float(f),
      :signal => read_float(f),
      :n_pairs => read_ushort(f),
      :n_pairs_used => read_ushort(f)
    }

    pretty_print_hash(h, "read_expression_results_row") if @verbosity == :debug
    
    return h
  end

  def read_data_sets
    File.open(@filename, 'rb') do |f|
      @data_groups.each do |data_group|
        
        f.seek(data_group[:pos_first_data_set])

        h = {
          :pos_first_data_element => read_int(f),
          :pos_next_data_set => read_int(f),
          :data_set_name => read_string(f, :wide),
          :n_parameters => read_int(f),
          :parameters => [],
          :n_columns => 0,
          :columns => []
        }

        h[:n_parameters].to_i.times do
          h[:parameters] << read_parameter(f)
        end

        h[:n_columns] = read_int(f)

        h[:n_columns].to_i.times do
          h[:columns] << read_column(f)
        end
        
        @data_sets << h
        
        l = @data_sets.length

        pretty_print_hash(h, "Data Set Header (#{l})")
        pretty_print_parameters(h, "Parameters (#{l})")
        pretty_print_columns(h[:columns], "Columns (#{l})")
        
        f.seek(h[:pos_first_data_element])

        i = 1
        while f.tell < @filesize
          puts "f.tell is #{f.tell} / #{h['data_set_name']}" if @verbosity == :debug

          # fixme -- needs to be data-driven based on file type genotyping or expression, etc.
          # hack
          # if h[:pos_first_data_element] == 716591
          #   read_background_zone_data_row(f)
          # else
          #   read_expression_results_row(f)
          # end

          row, call = read_data_row(f)
          puts "#{i} #{row[0]} #{call}" unless @verbosity == :quiet
          if i == @maxlines then break
          else i += 1
          end
        end
      end
    end
  end

  # fixme: dump from object. don't read file here
  def write_data_sets(outfilename)
    File.open(@filename, 'rb') do |f|

      pretty_print_header("\nWriting to #{outfilename}")
      
      @data_sets.each do |data_set|
        f.seek(data_set[:pos_first_data_element])
        
        i = 1
        outfile = File.open(outfilename, 'wb')
        CSV::Writer.generate(outfile) do |csv|
          while f.tell < @filesize
            row, call = read_data_row(f)
            csv << [row[0], call]
            
            if i == @maxlines then break
            else i += 1
            end
          end
        end
      end
    end
  end
end

# The CEL file stores the results of the intensity calculations on the pixel
# values of the DAT file. This includes an intensity value, standard deviation
# of the intensity, the number of pixels used to calculate the intensity
# value, a flag to indicate an outlier as calculated by the algorithm and a
# user defined flag indicating the feature should be excluded from future
# analysis. The file stores the previously stated data for each feature on the
# probe array
class CEL < CCGeneric
  def initialize(filename, maxlines)
    super(filename, maxlines)
    read_header
    read_data_groups
    read_data_sets
  end
end
