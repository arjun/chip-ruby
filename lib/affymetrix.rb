# 
# Simple Parser for Affymetrix files in binary format
#
# See http://www.affymetrix.com/Auth/support/developer/fusion/file_formats.zip
# specifically chp-gtc.html and generic.html
#
# Author::    Arjun Sanyal (mailto:arjun.sanyal@childrens.harvard.edu)
# Copyright:: Children's Hospital Boston
# License:: GPLv2
#
#--
#
# Todo
# * tests
# * CNCNF and LOH

# The Command Console generic data file format is a file format developed by
# Affymetrix for storing a variety of Affymetrix data and results including
# scanner acquisition data and intensity and probe array analysis results.

require 'csv'

class CCGeneric

  attr_reader :filename
  VALUE_TYPES = [:byte, :ubyte, :short, :ushort, :int, :uint, :float, :string, :wstring]

  # Init the Command Console Generic date file (parent of all other files)
  # params:
  # - filename (string, required)
  # - maxlines (int, defaults to 100)
  # - verbosity (can be :normal, :verbose, :debug, :quiet)
  def initialize(params)
    
    @filename = params[:filename]
    @filesize = File.size(@filename)
    @maxlines = params[:maxlines]
    @verbosity = params[:verbosity] || :normal

    @file_header = {}
    @generic_data_headers = []
    @generic_data_header_parameters = []
    @data_groups = []
    @data_sets = []
    
    puts "Filename\n--------\n#{@filename}\n\n" unless @verbosity == :quiet
  end

  #--
  # methods for reading raw bytes
  #
  
  def read_int(f)
    f.read(4).unpack('N')[0].to_i
  end
  
  def read_char(f)
    f.read(1).unpack('C')[0].to_s
  end

  def read_string(f, wide=nil)
    n = f.read(4).unpack('N')[0]
    puts "\ndebug: read_string: n = #{n.to_s}" if @verbosity == :debug
    wide ? f.read(n*2).to_s : f.read(n).unpack('a'+n.to_s).to_s
  end
  
  def read_parameter(f)
    [read_string(f, :wide), read_string(f), read_string(f, :wide)]
  end

  def read_column(f)
    [read_string(f, :wide), read_char(f), read_int(f)]
  end

  #--
  # methods for printing
  #

  def pretty_print_header(header)
    return if @verbosity == :quiet
    puts header + "\n"
    header.length.times { |l| print "-" }
    puts "\n"
  end
  
  def pretty_print_parameters(h, header)
    return if @verbosity == :quiet or @verbosity == :normal
    pretty_print_header(header)
    h['parameters'].each do |p|
      puts "#{p[0]} = #{p[1]} (#{p[2]})"
    end
    puts "\n"
  end

  def pretty_print_columns(columns, header)
    return if @verbosity == :quiet
    pretty_print_header(header)
    columns.each do |c|
      puts "#{c[0]}, type: #{VALUE_TYPES[c[1].to_i]}, size: #{c[2]}"
    end
    puts "\n"
  end

  def pretty_print_hash(h, header)
    return if @verbosity == :quiet
    pretty_print_header(header)
    h.each_pair { |key, value| puts "#{key} = #{value}" }
    puts "\n"
  end

  #--
  # methods for reading file structure
  # 

  def read_file_header(f)
    @file_header = {  
      'magic_number' => read_char(f), 
      'version_number' => read_char(f),
      'n_data_groups' => read_int(f),
      'pos_first_data_group' => read_int(f)
    }
  end
  
  def read_generic_data_headers(f)
    h = {
      'data_type_id' => read_string(f),
      'unique_file_id' => read_string(f),
      'created_at' => read_string(f),
      'locale' => read_string(f, :wide), # not wstring in spec?
      'n_parameters' => read_int(f),
      'parameters' => [],
      'n_parent_file_headers' => nil,
      'parent_file_headers' => []
    }
    
    h['n_parameters'].to_i.times do
      h['parameters'] << read_parameter(f)
    end

    pretty_print_parameters(h, 'Parameters') 

    h['n_parent_file_headers'] = read_int(f)

    h['n_parent_file_headers'].times do |n|
      read_generic_data_headers(f)
    end

    @generic_data_headers << h
  end
    
  def read_header
    File.open(@filename, 'rb') do |f|
      read_file_header(f)
      pretty_print_hash(@file_header, "File Header")
      
      puts "Hint: set 'verbosity' to see all parameters and parent file headers\n\n" if @verbosity == :normal
            
      read_generic_data_headers(f)
      pretty_print_hash(@generic_data_headers[0], "Generic Data Header (w/o Parent File Headers)")
    end
  end
  
  #-- fixme: buggy with multiple?
  def read_data_groups
    File.open(@filename, 'rb') do |f|
      f.seek(@file_header['pos_first_data_group'])

      h = { 
        'pos_next_data_group' => read_int(f),
        'pos_first_data_set' => read_int(f),
        'n_data_sets' => read_int(f),
        'data_group_name' => read_string(f, :wide)
      }

      # fixme
      puts "XXXXXXXXXX #{h['pos_next_data_group']} #{@filesize}\n" if @verbosity == :debug
      
      if h['pos_next_data_group'] < @filesize then
        f.seek(h['pos_next_data_group'])
        read_data_groups
      end
      
      @data_groups << h
      
      pretty_print_hash(h, 'Data Group Header')
    end
  end
end

# The CHP files generated by the Genotyping Console software contain SNP
# analysis results from the Birdseed and BRLMM genotyping algorithms.
class CHP < CCGeneric
  def initialize(filename, *rest)
    super(filename, *rest)
    read_header
    read_data_groups
    read_data_sets
  end

  def read_data_row(f)
    n = read_int(f)
    row = f.read(n+14).unpack('a'+n.to_s+'CgggC')
    call = case row[1]
            when 6 then 'AA'
            when 7 then 'BB'
            when 8 then 'AB'
            else        'No call'
           end
    return row, call
  end

  def read_data_sets
    File.open(@filename, 'rb') do |f|
      @data_groups.each do |data_group|
        
        f.seek(data_group['pos_first_data_set'])

        h = {
          'pos_first_data_element' => read_int(f),
          'pos_next_data_set' => read_int(f),
          'data_set_name' => read_string(f, :wide),
          'n_parameters' => read_int(f),
          'parameters' => [],
          'n_columns' => 0,
          'columns' => []
        }

        pretty_print_hash(h, 'Data Set Header')

        h['n_parameters'].to_i.times do
          h['parameters'] << read_parameter(f)
        end

        pretty_print_parameters(h, 'Parameters')

        h['n_columns'] = read_int(f)

        h['n_columns'].to_i.times do
          h['columns'] << read_column(f)
        end
        
        pretty_print_columns(h['columns'], 'Columns')
        
        @data_sets << h
        
        f.seek(h['pos_first_data_element'])

        i = 1
        while f.tell < @filesize
          row, call = read_data_row(f)
          puts "#{i} #{row[0]} #{call}" unless @verbosity == :quiet
          if i == @maxlines then break
          else i += 1
          end
        end
      end
    end
  end

  # fixme: dump from object. don't read file here
  def write_data_sets(outfilename)
    File.open(@filename, 'rb') do |f|

      pretty_print_header("\nWriting to #{outfilename}")
      
      @data_sets.each do |data_set|
        f.seek(data_set['pos_first_data_element'])
        
        i = 1
        outfile = File.open(outfilename, 'wb')
        CSV::Writer.generate(outfile) do |csv|
          while f.tell < @filesize
            row, call = read_data_row(f)
            csv << [row[0], call]
            
            if i == @maxlines then break
            else i += 1
            end
          end
        end
      end
    end
  end
end

# The CEL file stores the results of the intensity calculations on the pixel
# values of the DAT file. This includes an intensity value, standard deviation
# of the intensity, the number of pixels used to calculate the intensity
# value, a flag to indicate an outlier as calculated by the algorithm and a
# user defined flag indicating the feature should be excluded from future
# analysis. The file stores the previously stated data for each feature on the
# probe array
class CEL < CCGeneric
  def initialize(filename, maxlines)
    super(filename, maxlines)
    read_header
    read_data_groups
    read_data_sets
  end
end
